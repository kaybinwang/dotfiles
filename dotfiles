#!/usr/bin/env bash

################################################################################
#
# dotfiles: Automated dotfile setup and system configuration.
#
# TODO: opener about setting up dev environment.
#
# This script is used for keeping configuration files in $HOME in sync with the
# ones that are in this directory.
#
# TODO: document linking, system setup, git setup, backing up existing files.
#
################################################################################

set -e

# TODO: maybe delete this

RESET_COLOR="$(tput sgr 0)"
RED="$(tput setaf 1)"
GREEN="$(tput setaf 2)"
YELLOW="$(tput setaf 3)"
BLUE="$(tput setaf 4)"
MAGENTA="$(tput setaf 5)"
CYAN="$(tput setaf 6)"
LIGHT_CYAN="$(tput bold)$(tput setaf 6)"
LIGHTGRAY=$(echo -en '\033[00;37m')
LRED=$(echo -en '\033[01;31m')
LGREEN=$(echo -en '\033[01;32m')
LYELLOW=$(echo -en '\033[01;33m')
LBLUE=$(echo -en '\033[01;34m')
LMAGENTA=$(echo -en '\033[01;35m')
LPURPLE=$(echo -en '\033[01;35m')
LCYAN=$(echo -en '\033[01;36m')
WHITE=$(echo -en '\033[01;37m')

DF_PROG_NAME="$(basename "$0")"
DEBUG=1

DF_INFO_CMD='info'
DF_SYNC_CMD='sync'
DF_BACKUPS_CMD='backups'

DF_BACKUP_PATH="$HOME/.dotfiles_backup"

ERR_INVALID_ARG=200
ERR_SYNC_INVALID_ARG=201

function df_usage() {
  cat <<EOF
Usage: $DF_PROG_NAME [-dh]

Options:
	-h	Prints this message.

	-d	Enables debug mode.

Subcommands:
	$DF_INFO_CMD	Displays information about

	$DF_SYNC_CMD	Syncs, backing up existing configuration if necessary.

	$DF_BACKUPS_CMD	list
EOF
}

function df_echo() {
  echo -e "$*"
}

function df_debug() {
  if [ $DEBUG -eq 0 ]; then
    echo -e "${LIGHT_CYAN}[DEBUG]${RESET_COLOR} ${DF_PROG_NAME}: $*"
  fi
}

function df_error() {
  echo -e "${RED}${DF_PROG_NAME}: ${*}${RESET_COLOR}" 1>&2
}

function df_date_rfc() {
  date -u +%Y-%m-%dT%H-%M-%SZ
}

################################################################################
# df_sync: Subcommand for
################################################################################

function df_sync() {
  # Parse options and shift to real arguments
  local OPTIND
  while getopts 'dhn' o; do
    case "$o" in
      d)
        DEBUG=0
        ;;
      h)
        exit $ERR_SYNC_INVALID_ARG
        ;;
      *)
        df_echo "Unrecognized option: $o"
        exit $ERR_SYNC_INVALID_ARG
        ;;
    esac
  done
  shift $((OPTIND-1))

  df_echo 'Syncing dotfiles...'

  local -r backup_dir="$DF_BACKUP_PATH/$(df_date_rfc)"

  # enforce exactly one trailing slash
  local dotfile_root="${DOTFILE_PATH%/}/"

  local dotfile
  while read -r dotfile; do
    [ -z "$dotfile" ] && continue

    local dotfile_relpath="${dotfile#$dotfile_root}"
    df_symlink_to_home "$dotfile_relpath" "$backup_dir"
    echo
  done <<< "$(find "$DOTFILE_PATH" -type f)"

  df_echo 'Finished syncing dotfiles!'
}

#
# df_symlink_to_home $1
#
# Creates a soft symlink from dst -> src
#
# If dst already exists, then it is backed up to 
# (dirname backup_dir/src) if backup_dir provided
#
# please use relative paths
#
function df_symlink_to_home() {
  local -r dotfile_relpath="$1"
  local -r backup_root="$2"

  local -r src="$DOTFILE_PATH/$dotfile_relpath"
  local -r dst="$HOME/$dotfile_relpath"

  df_echo "Creating symlink ${BLUE}$dst${RESET_COLOR} -> ${CYAN}$src${RESET_COLOR}"
  df_debug "Using ${YELLOW}$dotfile_relpath${RESET_COLOR} as the relative path."
  if [ -e "$dst" ]; then
    # Only backup if a backup directory was provided
    if [ -z "$backup_root" ]; then
      df_error "Unable to symlink. File $dst already exists."
      return 1
    fi

    df_debug "${BLUE}$dst${RESET_COLOR} already exists. Backing up file before proceeding..."

    local -r backup_file="$backup_root/$dotfile_relpath"
    local -r backup_dir="$(dirname "$backup_file")"
    if [ ! -d "$backup_dir" ]; then
      df_debug "Backup directory DNE. Creating $backup_dir ..."
      mkdir -p "$backup_dir"
    fi
    df_echo "File already exists. Backing up ${BLUE}$dst${RESET_COLOR} -> ${GREEN}$backup_file${RESET_COLOR}"
    mv "$dst" "$backup_dir"
  fi

  # Check to make sure the parent directories for src exist before linking
  local -r dst_dir="$(dirname "$dst")"
  if [ ! -d "$dst_dir" ]; then
    df_debug "Directory $dst_dir DNE. Creating it..."
    mkdir -p "$dst_dir"
  fi
  ln -s "$src" "$dst"
}

function df_sync_usage() {
  cat <<EOF
Usage: $DF_PROG_NAME $DF_SYNC_CMD [-dhn]

Options:
	-h	Prints this message.

	-d	Enables debug mode.

	-s	Don't back up existing symlinks.
EOF
}


################################################################################
# Subcommand for handling backups
################################################################################
function df_backups() {
  # Parse options and shift to real arguments
  local OPTIND
  while getopts 'dDhr' o; do
    case "$o" in
      d)
        DEBUG=0
        ;;
      h)
        exit $ERR_SYNC_INVALID_ARG
        ;;
      *)
        df_echo "Unrecognized option: $o"
        exit $ERR_SYNC_INVALID_ARG
        ;;
    esac
  done
  shift $((OPTIND-1))

  find "$DF_BACKUP_PATH" ! -path "$DF_BACKUP_PATH" -type d -maxdepth 1 | xargs basename | sort
}

################################################################################
#
# main: Main entry point for executable.
#
# If DOTFILE_PATH is not set, then main will set it to the absolute directory
# that this script lives in, resolving all symlinks and relative paths. It will
# also append the variable to .bash_extras and export it as a global.
#
# Env:
#   DOTFILE_PATH (required directory)
#
# Arguments:
#   A list of packages (string[])
#
# Returns an error if:
#   Setup of any of the packages fail.
#
################################################################################
function main() {
  # Invariants
  if [ -z "$DOTFILE_PATH" ]; then
    df_error "${DF_PROG_NAME}: DOTFILE_PATH is not set."
    exit $ERR_INVALID_ARG
  elif [ ! -d "$DOTFILE_PATH" ]; then
    df_error "${DF_PROG_NAME}: DOTFILE_PATH is not a directory."
    exit $ERR_INVALID_ARG
  elif [ "$#" -eq 0 ]; then
    exit $ERR_INVALID_ARG
  fi

  # Parse options and shift to real arguments
  local OPTIND o
  while getopts 'dh' o; do
    case "$o" in
      d)
        DEBUG=0
        ;;
      h)
        exit $ERR_INVALID_ARG
        ;;
      *)
        df_echo "Unrecognized option: $o"
        exit $ERR_INVALID_ARG
        ;;
    esac
  done
  shift $((OPTIND-1))

  local subcommand="$1"
  shift
  case "$subcommand" in
    $DF_INFO_CMD)
      df_info "$*"
      ;;
    $DF_SYNC_CMD)
      df_sync "$*"
      ;;
    $DF_BACKUPS_CMD)
      df_backups "$*"
      ;;
    *)
      df_echo "Unrecognized command: $1"
      exit $ERR_INVALID_ARG
      ;;
  esac
}

function handle_error() {
  local rv="$?"
  local line_number=$1
  case $rv in
    0)
      exit 0
      ;;
    $ERR_SYNC_INVALID_ARG)
      df_sync_usage
      exit 1
      ;;
    $ERR_INVALID_ARG)
      df_usage
      exit 1
      ;;
    *)
      df_error "$line_number: Unknown Error"
      exit $rv
      ;;
  esac
}
trap 'handle_error $LINENO $?' EXIT

main "$@"
