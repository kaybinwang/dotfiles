#!/bin/bash

set -e

# TODO: diff beteween force= and force

REINSTALL=false
DEBUG=false

#TODO: use real doc syntax, pretty print
function usage() {
  cat <<EOF
Usage: $(bold "$0") [-h | -l | -c $(underline package) | -dr $(underline package) ... ]

Options:
	$(bold -h)	Prints this message.

	$(bold -d)	Enables debug mode.

	$(bold -r)	Reinstalls the packages.

	$(bold -l)	Lists all available packages.

	$(bold -c)	$(underline package)
		Creates a template for a new package.

EOF
}

# setup:
#   caches results
# requires to be in DOTFILE_PATH
function setup() {
  print_info "Installing package $pkg..."
  local -r pkg="$1"
  local -r pkg_script="./$pkg/setup"
  local -r cache="./$pkg/.setup"

  if [ ! -f "$pkg_script" ]; then
    print_error "Unable to find package $pkg."
    return 1
  fi
  if [ ! -x "$pkg_script" ]; then
    print_error "$pkg is not executable."
    return 1
  fi
  if [ -e "$cache" ]; then
    print_warning "$pkg already installed. Reinstall with '$0 -r $pkg'"
    return 0
  fi
  if ! eval "./$pkg/setup"; then
    return 1
  fi
  touch "$cache"
  return 0
}

#
# main
#
# Assumes we are in DOTFILE_PATH directory.
#
function main() {
  if [ "$#" -eq 0 ]; then
    usage
    exit 0
  fi
  while getopts ":d:v:" o; do
    case "$o" in
      r)
        REINSTALL=true
        ;;
      d)
        DEBUG=true
        ;;
      l)
        #TODO: list all available packages.
        # use python script
        return 0
        ;;
      h)
        usage
        return 0
        ;;
      *)
        echo "Unrecognized option: $o"
        return 0
        ;;
    esac
  done
  shift $((OPTIND-1))

  for pkg in "$@"; do
    setup "$pkg"
  done
}

if [ ! -d "$DOTFILE_PATH" ]; then
  cat <<EOF 2>&1
ERROR: DOTFILE_PATH is not set.
Please run bootstrap.
EOF
  exit 1
fi

pushd "$DOTFILE_PATH" &>/dev/null
source util/dirname.sh
source util/print.sh
main "$@"
popd &>/dev/null
